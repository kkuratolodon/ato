name: PO Upload Stress Test

on:
  workflow_dispatch:
    # Workflow can be triggered manually from GitHub UI

jobs:
  stress-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install k6
        run: |
          echo "Installing required dependencies..."
          sudo apt-get update
          sudo apt-get install -y gnupg2 dirmngr

          echo "Adding k6 repository and installing k6..."
          curl -s https://dl.k6.io/key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/k6-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install -y k6
          echo "k6 installation completed."

      - name: Prepare Test Directory
        run: |
          mkdir -p backend/tests/stress
          ls -la sample_file/purchase_order/

      - name: Copy Sample Files
        run: |
          echo "Attempting to copy sample PO files..."
          cp -f sample_file/purchase_order/Sample1_Bike_PO.pdf backend/tests/stress/ && echo "Sample PO file copied successfully" || echo "Failed to copy PO sample file, checking if file exists..."
          
          # Verify the file was copied or exists at the destination
          if [ -f backend/tests/stress/Sample1_Bike_PO.pdf ]; then
            echo "âœ“ Sample1_Bike_PO.pdf exists in test directory"
            ls -la backend/tests/stress/
          else
            echo "âš ï¸ Sample file not found or not copied. Finding available sample files:"
            find sample_file -name "*.pdf" | grep -i "bike\|po\|purchase"
            
            # Try alternative path if standard path fails
            if [ -f sample_file/purchase_order/Sample1_Bike_PO.pdf ]; then
              echo "File exists at expected path but copy failed, trying with absolute path"
              cp -f "$(pwd)/sample_file/purchase_order/Sample1_Bike_PO.pdf" backend/tests/stress/
            fi
          fi

      - name: Run Purchase Order Upload Stress Test
        run: |
          echo "Starting Purchase Order Upload Stress Test..."
          cd backend/tests/stress
          ls -la
          k6 run -e LOAD_CLIENT_ID=${{ secrets.LOAD_CLIENT_ID }} -e LOAD_CLIENT_SECRET=${{ secrets.LOAD_CLIENT_SECRET }} -e API_BASE_URL=${{ secrets.API_BASE_URL }} upload-po-stress-test.mjs | tee upload-po-stress-test.log || echo "Purchase Order Upload Stress Test completed with issues!"
          echo "Purchase Order Upload Stress Test completed."

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        with:
          name: po-upload-stress-test-results
          path: backend/tests/stress/upload-po-stress-test.log

      - name: Extract and Process Degradation Analysis
        run: |
          cd backend/tests/stress
          echo "Extracting degradation analysis from test results..."
          
          # Check if the log file exists
          if [ ! -f upload-po-stress-test.log ]; then
            echo "ERROR: Test log file not found!"
            exit 1
          fi
          
          # Install bc for floating point calculations if needed
          sudo apt-get install -y bc
          
          # Count timeout errors and failed requests more comprehensively
          TIMEOUT_COUNT=$(grep -c "Status 504" upload-po-stress-test.log || echo "0")
          FAILED_COUNT=$(grep -c "Request gagal" upload-po-stress-test.log || echo "0")
          SUCCESS_COUNT=$(grep -c "Request berhasil" upload-po-stress-test.log || echo "0")
          
          # Calculate total request count and error rate
          TOTAL_COUNT=$((SUCCESS_COUNT + FAILED_COUNT))
          
          if [ "$TOTAL_COUNT" -gt 0 ]; then
            ERROR_RATE=$(echo "scale=2; ($FAILED_COUNT + $TIMEOUT_COUNT) * 100 / $TOTAL_COUNT" | bc)
          else
            ERROR_RATE="0.00"
          fi
          
          echo "Total timeout errors (504): $TIMEOUT_COUNT"
          echo "Total failed requests: $FAILED_COUNT"
          echo "Total successful requests: $SUCCESS_COUNT" 
          echo "Total requests: $TOTAL_COUNT"
          echo "Error rate: ${ERROR_RATE}%"
          
          echo "$TIMEOUT_COUNT" > timeout_count.txt
          echo "$ERROR_RATE" > error_rate.txt
          
          # Extract sections of the log for processing
          grep -A 50 "=== Purchase Order Upload Stress Test Summary ===" upload-po-stress-test.log > raw_summary.txt || echo "Summary not found"
          grep -A 50 "=== Analisis Degradasi Sistem ===" upload-po-stress-test.log > raw_degradation.txt || echo "Degradation analysis not found"
          
          # Process and format the summary text properly
          cat raw_summary.txt | sed 's/^--$//' > summary.txt
          cat raw_degradation.txt | sed 's/^--$//' > degradation_analysis.txt
          
          # Extract performance table - using more reliable approach
          grep -A 15 "Performa Per Tahap Load Testing:" upload-po-stress-test.log > raw_performance.txt || echo "Performance table not found"
          cat raw_performance.txt | sed 's/^--$//' > performance_table.txt
          
          # Extract conclusion for better readability
          grep -A 10 "=== Ringkasan Ketahanan Sistem ===" upload-po-stress-test.log > raw_conclusion.txt || echo "Conclusion not found"
          cat raw_conclusion.txt | sed 's/^--$//' > conclusion.txt
          
          # Create fallback table directly - bypass the complex sed command
          echo "Creating performance summary directly from test data..."
          echo "## Performance Summary" > performance_summary.md
          echo "| Stage | VUs | Requests | Error Rate | Failed Requests (504) | Latency p95 (ms) | Status |" >> performance_summary.md
          echo "| ----- | --- | -------- | ---------- | -------------------- | --------------- | ------ |" >> performance_summary.md
          
          # Define VU targets for each stage - use bash array properly
          declare -a VU_TARGETS=(10 15 18 20 30 40 60 80 100 300)
          
          # Create simple table directly from log data without complex regex
          for i in {0..9}; do
            # Count successful and failed requests per stage - ensure numbers with || echo 0
            STAGE_REQUESTS=$(grep -c "Request berhasil.*Stage: $i" upload-po-stress-test.log || echo 0)
            STAGE_FAILURES=$(grep -c "Request gagal.*Stage: $i" upload-po-stress-test.log || echo 0)
            STAGE_TIMEOUTS=$(grep -c "Status 504.*Stage: $i" upload-po-stress-test.log || echo 0)
            
            # Calculate total requests - ensure they're treated as integers
            TOTAL_REQUESTS=$((STAGE_REQUESTS + STAGE_FAILURES))
            
            # Calculate error rate including timeouts in the error count
            if [ "$TOTAL_REQUESTS" -gt 0 ] || [ "$STAGE_TIMEOUTS" -gt 0 ]; then
              # Use bc for floating point calculation - include timeouts in error rate
              ERROR_RATE=$(echo "scale=2; ($STAGE_FAILURES + $STAGE_TIMEOUTS) * 100 / ($TOTAL_REQUESTS + $STAGE_TIMEOUTS)" | bc 2>/dev/null || echo "0.00")
            else
              ERROR_RATE="0.00"
            fi
            
            # Handle potential empty or invalid results
            if [ -z "$ERROR_RATE" ] || [ "$ERROR_RATE" = "0" ] || [ "$ERROR_RATE" = "" ]; then
              ERROR_RATE="0.00"
            fi
            
            # Determine status based on timeouts and error rate
            if [ "$STAGE_TIMEOUTS" -gt 0 ]; then
              STATUS="âš ï¸ Timeouts Detected"
            else
              STATUS="Normal"
            fi
            
            # Get latency from performance table if available
            LATENCY_P95=$(grep -E "^$i \|.*\|.*\|.*\|.*\|.*\|" performance_table.txt | awk -F'|' '{print $6}' | tr -d ' ' || echo "N/A")
            
            # If latency is empty, use N/A
            if [ -z "$LATENCY_P95" ] || [ "$LATENCY_P95" = "" ]; then
              LATENCY_P95="N/A"
            fi
            
            # Create line for markdown table - use array reference with proper syntax
            VU_TARGET="${VU_TARGETS[$i]}"
            echo "| $i | $VU_TARGET | $TOTAL_REQUESTS | ${ERROR_RATE}% | $STAGE_TIMEOUTS | $LATENCY_P95 | $STATUS |" >> performance_summary.md
            
            # Save raw data for debugging
            echo "Stage $i: Requests=$STAGE_REQUESTS, Failures=$STAGE_FAILURES, Timeouts=$STAGE_TIMEOUTS, Error Rate=${ERROR_RATE}%" >> raw_stats.txt
          done
          
          cat performance_summary.md
          
          echo "Analysis complete. Performance summary saved to performance_summary.md"

      - name: Generate Summary
        run: |
          echo "# Purchase Order Upload Stress Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add total timeout count and error rate
          if [ -f "backend/tests/stress/timeout_count.txt" ] && [ -f "backend/tests/stress/error_rate.txt" ]; then
            TIMEOUT_COUNT=$(cat backend/tests/stress/timeout_count.txt)
            ERROR_RATE=$(cat backend/tests/stress/error_rate.txt)
            
            # Ensure error rate matches timeout percentage - future-proofing for consistency
            if [ -f "backend/tests/stress/summary.json" ]; then
              # Extract timeout percentage from JSON using grep and basic text processing
              TIMEOUT_PERCENTAGE=$(grep -o '"timeoutPercentage":[^,]*' backend/tests/stress/summary.json | cut -d':' -f2)
              if [ ! -z "$TIMEOUT_PERCENTAGE" ]; then
                ERROR_RATE=$TIMEOUT_PERCENTAGE
              fi
            fi
            
            echo "## ðŸš¨ Total Error (504 Timeout) Count: $TIMEOUT_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Overall Error Rate: ${ERROR_RATE}%" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Use performance_summary.md directly if available
          if [ -f "backend/tests/stress/performance_summary.md" ]; then
            echo "## Performa Per Tahap Load Testing" >> $GITHUB_STEP_SUMMARY
            cat backend/tests/stress/performance_summary.md | grep -v "^## Performance Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Include the cleaner summary directly from the stress test output
          if [ -f "backend/tests/stress/summary.txt" ]; then
            echo "## Ringkasan Hasil Test" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat backend/tests/stress/summary.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Include conclusion
          if [ -f "backend/tests/stress/conclusion.txt" ]; then
            echo "## Analisis Titik Degradasi Sistem" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat backend/tests/stress/conclusion.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Extract specific information about degradation point and crash point for better visibility
            DEGRADATION_POINT=$(grep -E "Sistem mulai menunjukkan tanda-tanda degradasi" backend/tests/stress/conclusion.txt || echo "Tidak terdeteksi titik degradasi")
            CRASH_POINT=$(grep -E "Sistem mengalami crash/kegagalan signifikan" backend/tests/stress/conclusion.txt || echo "")
            DEGRADATION_PATTERN=$(grep -E "Pola Degradasi:" backend/tests/stress/conclusion.txt || echo "Tidak terdeteksi pola degradasi")
            
            echo "## Ringkasan Ketahanan Sistem" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ” **Titik Degradasi:** ${DEGRADATION_POINT#*ðŸ” }" >> $GITHUB_STEP_SUMMARY
            
            if [ -n "$CRASH_POINT" ]; then
              echo "ðŸ’¥ **Titik Crash:** ${CRASH_POINT#*ðŸ’¥ }" >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… **Tidak terdeteksi crash system selama pengujian**" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "ðŸ”„ **${DEGRADATION_PATTERN#*ðŸ”„ }**" >> $GITHUB_STEP_SUMMARY
          fi